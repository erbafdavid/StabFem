/* ======================================

				Macros STABFEM
		-- Disque poreux tournant --
	
   ======================================

   PROGRAM Macros_StabFem.edp
   
	CUSTOMIZED CASE FOR POROUS SWIRLING JET

	This file contains the case-dependent Macros for boundary conditions and postprocessing output.
	
	This file can be customized according to requirements but it must contain the following macros :
		Boundary conditions : 
			macro BoundaryconditionsBaseFlow(du,u,v) 
			macro BoundaryconditionsStability(u,v,symmetry)
		For post-processsing purposes :
			macro SFWriteBaseFlow(filename,u,type,iter)
			macro SFWriteMode(namefile,u,ev,shift,type,iter)

	The following case is for the AXISYMMETRIC DISK and includes the additional macros
	required to compute lift and drag forces : Trainee(u,symmetry) and Portance(u,symmetry)
...................................................... */

string ffdatadir = "WORK\\";
int bclat=4,bcinlet=1,bcoutflow=3,bcwall=2,bcaxis=6;

 /* -------------------
		FreeFemPlot 
    ------------------- */
	
	IFMACRO(!FREEFEMPLOTS)
		macro FREEFEMPLOTS YES//EOM
	ENDIFMACRO

 /* -------------------
		problemtype 
    ------------------- */

	IFMACRO(!problemtype)
		macro problemtype AxiXR //EOM
	ENDIFMACRO

 /* ---------------------
		ncomponentsBF 
    --------------------- */

	IFMACRO(!ncomponentsBF)
		macro ncomponentsBF 3//EOM  	// THIS PARAMETERS SHOULD BE 2 if BASE FLOW is (U,V,P) and 3 if it is (U,V,W,P) (case with rotation)
	ENDIFMACRO
	
 /* ------------------
		IsInObject 
    ------------------ */
	
	// macro S1f(x,y) (1*(y>SFGeomRdisk)*(abs(x)>SFGeomHdisk/2))//EOM
	// macro S1p(x,y) ((1/(Porosity^2))*(y<=SFGeomRdisk)*(abs(x)<=SFGeomHdisk/2))//EOM
	
	// macro S2f(x,y) (1*(y>SFGeomRdisk)*(abs(x)>SFGeomHdisk/2))//EOM
	// macro S2p(x,y) ((1/Porosity)*(y<=SFGeomRdisk)*(abs(x)<=SFGeomHdisk/2))//EOM
	
	macro IsInObject(x,y) (1*(y<SFGeomRdisk)*(abs(x)<SFGeomHdisk/2))//EOM

	macro S1(x,y) (1+((1/Porosity^2-1)*IsInObject(x,y)))//EOM
	macro S2(x,y) (1+((1/Porosity-1)*IsInObject(x,y)))//EOM
	//macro S2jump (1/Porosity-1)//EOM
	
 /* ----------------------------------
		BoundaryconditionsBaseFlow 
    ---------------------------------- */
	
	macro BoundaryconditionsBaseFlow(du,up,v)
			on(bcinlet,du#x=1.0-up#x,du#r=-up#r)
			+ int1d(th,bcaxis)(du#r*v#r*1e30+du#phi*v#phi*1e30) 
			/*+ int1d(th,7)(du#r*v#r*1e30)*/
	//EOM

 /* -----------------------------------
		BoundaryconditionsStability 
    ----------------------------------- */

	macro BoundaryconditionsStability(u,v,m)
			on(bcinlet,u#x=0,u#r=0.0,u#phi=0.0)
			+ int1d(th,bcaxis)(u#x*v#x*1e30*(abs(m)>0)
			+(u#r*v#r+u#phi*v#phi)*1e30*(abs(m)!=1))
	//EOM


// HERE ARE SOME MACROS WHICH ARE USEFUL FOR POST-PROCESSING WITH AN AXI FLOW OVER A BLUFF BODY


 /* ---------------
		Trainee 
    --------------- */

	macro Trainee(u)   
		(
			int1d(th,2,91,92,93)(u#x*(u#x*N.x+u#r*N.y+u#phi*N.z)*2*pi*y) /* Momentum flux ? */
			+ int1d(th,2,91,92,93)(u#p*N.x*2*pi*y)
			- nu*int1d(th,2,91,92,93)( (2*dx(u#x)*N.x+(dx(u#r)+dy(u#x))*N.y)*2*pi*y)
		)
	//EOM

 /* ---------------
		CoupleX 
    --------------- */
// WARNING : momentum flux ???
	macro CoupleX(u)   
		(
			-nu*int1d(th,2,91,92,93)((dx(u#phi)*N.x+(-u#phi/y+dy(u#phi))*N.y)*y*2*pi*y)
		)
	//EOM

 /* ----------------
		Portance 
    ---------------- */

	macro Portance(im,u)   
		(
			int1d(th,2,91,92,93)(u#p*N.y*y)
			-nu*int1d(th,2,91,92,93)( (2*dy(u#r)*N.y+(dx(u#r)+dy(u#x))*N.x)*2*pi*y)
			+im*nu*int1d(th,2,91,92,93)( ( (dy(u#phi)-u#phi/y)*N.y + (dx(u#phi))*N.x ) *pi*y)
		)
	//EOM

 /* -------------------
		SFWriteMesh 
    ------------------- */
	
	macro SFWriteMesh(filename,TH)
		{
		ofstream fileFF(filename);
			fileFF << "### Data generated by Freefem++ ; " << endl;
            fileFF << "Mesh for the flow over/across a porous disk" << endl;
            fileFF << "datatype Mesh meshtype 2D" << endl;
			fileFF << "int np int Ndof real deltamin real deltamax" ;
			string PostProcessMeshDescription = " " ; /*description of customizable part*/
			fileFF << PostProcessMeshDescription << endl << endl ;
			fespace femp1N(TH,P1);
			fespace femp2xfemp2xfemp1N(TH,[P2,P2,P1]);	  
			femp2xfemp2xfemp1N [uNx,uNy,uNp];
			fileFF << TH.nv <<  endl << uNx[].n << endl ;
			cout << "#### Mesh information :" << endl;  
			cout << "## Number of vertices    " << TH.nv <<  endl;
			cout << "## Number of DOF : " << uNx[].n << endl << endl;  
			femp1N delta = hTriangle;
			cout << "## delta min : " << delta[].min << endl;
			cout << "## delta max : " << delta[].max << endl;
			fileFF << delta[].min << endl;
			fileFF << delta[].max << endl;   
		/*Next is customizable part ; here determination of the grid size at several points */ 
		}; 	 
	//EOM

 /* -----------------------
		SFWriteBaseFlow 
    ----------------------- */
	
	macro SFWriteBaseFlow(filename,u,typeFlow,iter)
		if(iter>=0)
			{
			fespace p1forff2m(th,P1);
			p1forff2m xx,yy;
				xx = x;
				yy = y;
			p1forff2m ut,vt,pt,vort;
				ut = u#x;
				vt = u#r;
				pt = u#p;
			IFMACRO(ncomponentsBF,3) 
				p1forff2m wt ; 
					wt = u#phi; 
			ENDIFMACRO
			vort = (dy(u#x)-dx(u#r)); /* vorticity */
			/* p1forff2m psi,phi;
				psi = u#psi;
			 solve Laplace(psi,phi, solver = CG) =
				int2d(th)(1/y*(dx(psi)*dx(phi)+dy(psi)*dy(phi)))
				- int2d(th)(-vort*phi)
				- int1d(th,bcinlet,bcoutflow,bclat,bcwall)((-N.x*u#x+N.y*u#r)*phi); */
			ofstream file(filename);
				{
				file << "### Data generated by Freefem++ ; " << endl;
				file << "BaseFlow for a an axisymmetric flow with porous region " << endl;
				IFMACRO(ncomponentsBF,2)
                   file << "datatype " << typeFlow << " datastoragemode ReP2P2P1 " << endl;
				   file << "real Re P1 ux P1 ur P1 p P1 vort real iter " ;
				ENDIFMACRO
				IFMACRO(ncomponentsBF,3)
                    file << "datatype " << typeFlow << " datastoragemode ReP2P2P2P1 " << endl;
					file << "real Re P1 ux P1 ur P1 uphi P1 p P1 vort real iter " ;
				ENDIFMACRO
				string PostProcessBaseFlowDescription = "real Fx real Lx real Mx real Darcy real Porosity real Omegax real Flux1 real Flux2 real Flux3"; /* customizable output */ 
				file << PostProcessBaseFlowDescription << endl << endl ; 
				file << Re << endl;	
					for (int j=0;j<ut[].n ; j++) file << ut[][j] << endl;
					for (int j=0;j<ut[].n ; j++) file << vt[][j] << endl;
				IFMACRO(ncomponentsBF,3)
					for (int j=0;j<ut[].n ; j++) file << wt[][j] << endl;
				ENDIFMACRO
					for (int j=0;j<ut[].n ; j++) file << pt[][j] << endl;
					for (int j=0;j<ut[].n ; j++) file << vort[][j] << endl;
					/* for (int j=0;j<ut[].n ; j++) file << psi[][j] << endl; */
				file << iter << endl;
				cout << "#### customisable output for WAKE OF A 2D BLUFF BODY : " << endl; 
				/* Calcul de la trainee */
				real FxMode = Trainee(u);
				cout << "#    Fx =  " << FxMode << endl;
				file << FxMode << " " ; 
				/* mesure de la longueur de recirculation 
				real Lx, Uap, Uav;
				if(iter>0)
				{
					real dx = 0.0001;real Uav = -2e-10;real Uap=-1e-10;int ix;
					for(ix=1;ix<20000;ix++)
						{   
						Uap = ut((SFGeomHdisk/2)+ix*dx,0);
						if(Uap*Uav<0){break;};
						Uav = Uap;	
						}
					real xav = (SFGeomHdisk/2)+(ix-1)*dx; 
					real xap = (SFGeomHdisk/2)+ix*dx;
					Lx = xav *(Uap)/(Uap-Uav) + xap *(-Uav)/(Uap-Uav);
				}
				else
				{
					Lx = 0;
				}
				cout << "#    Lx = " << Lx << endl << endl; 
				file << Lx << endl; */
				/* mesure de la longueur de recirculation V2 */
				real Lx, U1, U2;
				if(iter>0)
				{
					real dx = 0.0001;real U1 = 1;real U2;int ix;int ch=1;
					real x2,x1;
					for(ix=1;ix<20000;ix++)
						{
						x2 = ix*dx;
						U2 = ut((SFGeomHdisk/2)+ix*dx,0);
						if(U2*U1<0 && ch!=0)
							{
								x1 = x2;
								ch = ch-1;
							}
						else if(U2*U1<0 && ch==0){break;};
						U1 = U2;	
						}
					if(ch==0){Lx = x2-x1;}
					else{Lx = 0;};
				}
				else
				{
					Lx = 0;
				}
				cout << "#    Lx = " << Lx << endl << endl; 
				file << Lx << endl;
				IFMACRO(ncomponentsBF,3)
					real Mx = CoupleX(u) ;
					cout << "#    Cx =  " << Mx << endl; /* factor 2 because Fx = 1/2 Cx */
					file << Mx << " " ; 
				ENDIFMACRO
				IFMACRO(ncomponentsBF,2)
					file << 0 << endl;
				ENDIFMACRO
				file << Da << endl;
				file << Porosity << endl;
				file << Omegax << endl;
				real Flux1 = int1d(th,91)((u#x*N.x+u#r*N.y)*2*pi*y); 		/* ancienne version  int1d(th,91)(u#x*2*pi*y); */
				real Flux2 = int1d(th,92)((u#x*N.x+u#r*N.y)*2*pi*y);
				real Flux3 = int1d(th,93)((u#x*N.x+u#r*N.y)*2*pi*y);
				cout << "### Porous disk : Flow across disk surfaces " << endl;
				cout << " Flux1 = "  << Flux1 << " ; Flux2 = " << Flux2 << " ; Flux3 = " << Flux3 << endl;
				file << Flux1 << " " << Flux2 << " " << Flux3 << endl;
				}
			}
		else
			{
			ofstream file(filename);
				file << "### Data generated by Freefem++ ; " << endl;
				file << "BaseFlow NOT CONVERGED" << endl;
				file << "Format : " << endl;	
				file << "int iter " << endl;
				file << -1 << endl;
			};
	//EOM
	
 /* -------------------
		SFWriteMode 
    ------------------- */
	
	macro SFWriteMode(namefile,u,ev,shift,m,typeFlow,iter)
		{
		ofstream file(namefile);
			fespace p1forff2m(th,P1); 
			p1forff2m xx,yy;
			xx=x;
			yy=y;
			p1forff2m<complex> ux1,uy1,pp1,vort1;  		 
			 file << "### Data generated by Freefem++ ; " << endl;
    	 file << "Eigenmode for a 2D-incompressible problem " << endl;
    	 file << "datatype " << typeFlow << " datastoragemode CxP2P2P2P1 " << endl;
			string descriptionFF;
			if(typeFlow=="EigenModeD"||typeFlow=="HarmonicMode")
				{
				descriptionFF = "real Re int m complex lambda complex shift int iter P1c ux1 P1c uy1 P1c p1 P1c vort1 real AEnergy complex Cy";
				}
			else 
				{
				descriptionFF = "real Re int m complex lambda complex shift int iter P1c ux1Adj P1c uy1Adj P1c p1Adj P1c vort1Adj real AEnergyAdj complex CyAdj";
				}
			file << descriptionFF << endl << endl ; 
			file << Re  << endl << m << endl << real(ev) << " " << imag(ev) << " " << real(shift) << " " << imag(shift) << " " << iter << endl << endl;
			ux1=u#x;
			uy1=u#r;
			pp1=u#p;
			vort1=dy(u#x)-dx(u#r);
			for (int j=0;j<ux1[].n ; j++) file << real(ux1[][j]) << " " << imag(ux1[][j]) << endl;
			for (int j=0;j<ux1[].n ; j++) file << real(uy1[][j]) << " " << imag(uy1[][j]) << endl;
			for (int j=0;j<ux1[].n ; j++) file << real(pp1[][j]) << " " << imag(pp1[][j]) << endl;
			for (int j=0;j<ux1[].n ; j++) file << real(vort1[][j]) << " " << imag(vort1[][j]) << endl;
			cout << "#### customisable output for a mode in the WAKE OF A 2D BLUFF BODY : " << endl; 
			real AEnergyMode = sqrt(2*int2d(th)(abs(ux1)^2+abs(uy1)^2))*2; 
			/* nb here the factor 2 is because in mantic-lugo the radius is 1, while here it is 0.5 ! */
			cout << "#   Amplitude (with definition of Mantic-Lugo) = " << AEnergyMode << endl;
			file << AEnergyMode << endl;
			complex CyMode = 8/pi*Portance(1i*m,u); 
			cout << "#   Cy = " << CyMode << endl;
			file << 2*real(CyMode) << " " << 2*imag(CyMode) << endl;
		};
	//EOM	

//macro PostProcessBaseFlowOutput(file,u1,u2,p)	