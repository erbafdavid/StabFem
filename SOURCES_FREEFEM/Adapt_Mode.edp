//
//  PROGRAM Adapt_UVP.edp
//  adaptmesh for 2D flow PLUS EIGENMODE
//   
// Usage : FreeFem++ Adapt_Mode.edp "type"
//
//  INPUT PARAMETERS (from pipe) : "type" where type is "BFonly", "UVP", "UVWP", "S" (at the moment)
//
//	INPUT FILES :
// 		mesh.msh ->  mesh in Freefem format
//		BaseFlow.txt	-> guess base flow (generated by mesh generator, time integration or previous Newton)
//		AdaptField.txt -> field to which the adaptation has to be done (in addition to base flow)
// 		Data in this file depends upon option "type"
//			type = "UVP" -> P2xP2xP1 data (for instance 2D mode)
//			type = "UVWP" -> P2xP2xxP2xP1 data (for instance 3D mode) 
// 			type = "Comp" -> P2 data (for instance structural sensitivity)
//			type = "S" -> P2 data (for instance structural sensitivity for the incompressible 
//					       case or sensitivity to base flow modification in the compressible one)
//			type = "BFonly" -> no data, adaptation to base flow only
//  OUTPUT FILES :
//		mesh.msh -> New mesh
//		BaseFlow_guess.txt -> BaseFlow interpolated on new mesh (guess for next Newton)		
//		AdaptField_guess.txt -> data interpolated on new mesh(may be useful to provide initial guess for Shift/invert solver)
//		mesh_ans.msh, BaseFlow_ans.txt -> previous mesh and base flow to allow reconstruction in case adaptmesh was not successful 
// 		nb : BaseFlow.txt is removed, to force new computation with Newton
// 	ERROR MANAGEMENT : 
//
//  D. Fabre et al., June 2017
//




	verbosity = 0;
	include "Macros_StabFem.edp";
	
	string type;
	cout << "Select type of data ? [UVP, UVWP, Comp, S, BFonly]" << endl;
	cin >> type; 
	
	real Nbvx	= 50000.;		//maximun number of vertices
	real Thetamax	= 1e-3;			//minimum corner angle in degree
	real Verbosity	= 1; // warning : must be integer !
	bool Splitpbedge= false;
//	real Hmin	= .1e-4;           	//minimun edge size 
//	real Hmax	= .5;			//maximun edge size  	
//	real Ratio	= 10.;               	//ratio for the smoothing of the mesh
//	real error	= 1e-2;			//interpolation error level, it decreases on each iteration
// 
// NB ALL THESE PARAMETERS ARE NOW WRITTEN IN THIS FILE :
	include "Param_Adaptmesh.edp";


	exec("cp "+ffdatadir+"mesh.msh "+ffdatadir+"mesh_ans.msh");
	exec("cp "+ffdatadir+"mesh.ff2m "+ffdatadir+"mesh_ans.ff2m");
	exec("cp "+ffdatadir+"BaseFlow.txt "+ffdatadir+"BaseFlow_ans.txt");
	exec("cp "+ffdatadir+"BaseFlow.ff2m "+ffdatadir+"BaseFlow_ans.ff2m");


	 
	mesh th=readmesh(ffdatadir+"mesh.msh");
	mesh thold = th;
	int nvprev = th.nv;
	    
	fespace femp2(th,P2);   
        fespace femp1(th,P1);
        fespace femp0(th,P0);
        fespace femp2xfemp2xfemp1(th,[P2,P2,P1]);
        fespace femp2xfemp2xfemp2xfemp1(th,[P2,P2,P2,P1]);
	fespace XXxxxH(th,[P2,P2,P1,P1,P1]); /// 
        femp2xfemp2xfemp1 [vB,uB,pB]; // base flow
        femp2xfemp2xfemp2xfemp1 [vBS,uBS,wBS,pBS]; // base flow
	XXxxxH[uBc,vBc,pBc,TBc,rhoBc]; // compressible base flow
	XXxxxH<complex>[uc,vc,pc,Tc,rhoc]; // compressible structure for adaptation
	femp2xfemp2xfemp2xfemp1[uComp,vComp,pComp,TComp];
        femp2xfemp2xfemp1<complex> [vC,uC,pC];	// structure for adaptation (case UVP)
        femp2xfemp2xfemp2xfemp1<complex> [uCC,vCC,wCC,pCC];	// structure for adaptation (case UVWP)
        femp2 Sensitivity;
	
	cout << "###################################" << endl;
cout << endl << "       Adapt_Mode.edp        " << endl; 
cout << endl << "###################################" << endl << endl;
	

cout << endl << "#### Mesh information BEFORE ADAPT :" << endl;  
        cout << "#### Number of vertices    " << th.nv <<  endl;
	    cout << "### Dimension of matrices " << vB[].n << endl << endl;
	
	real Re;
	
	
	
/// LECTURE BASE FLOW	
	    
	    int NdimUVP = uB[].n;
    	int NdimUVWP = uBS[].n;
	int NdimUComp = uBc[].n;
    	int NdimBaseFlow;
    	real Reans;
	    {
          ifstream file(ffdatadir+"BaseFlow.txt");
          file >> NdimBaseFlow ;
    	}
		
	if(NdimBaseFlow == NdimUVP) 
	{
        cout << "Ndim = " << NdimUVP << " : reading UVP baseflow " << endl;
        ifstream file(ffdatadir+"BaseFlow.txt");
        file >> uB[];
        [vBS,uBS,wBS,pBS] = [vB,uB,0,pB];
		file >> Reans;
        }
        else if(NdimBaseFlow == NdimUVWP) 
        {
        cout << "Ndim = " << NdimUVWP << " : reading UVWP baseflow " << endl;
        ifstream file(ffdatadir+"BaseFlow.txt");
        file >> uBS[]; 
		file >> Reans;
        }
	else if(NdimBaseFlow == NdimUComp) 
        {
        cout << "Ndim = " << NdimUComp << " : reading UComp baseflow " << endl;
        ifstream file(ffdatadir+"BaseFlow.txt");
        file >> uBc[]; 
	file >> Reans;
        }
        else 
        {
        cout << " Error : Wrong dimension For BaseFlow_guess.txt file" << endl;
        };
    cout << " lecture of Base flow : Reynolds number = " << Reans << endl;

	Re = Reans;

	mesh thnew;	
	
	
// selection of the type of adaptation to be done 
	if(type=="BFonly")
	{
	if(NdimBaseFlow == NdimUComp) {[vBS,uBS,wBS,pBS] = [vBc,uBc,0,pBc];}
	thnew = adaptmesh(th,[vBS,uBS,wBS,pBS],
						nbvx=Nbvx,err=error,ratio=Ratio,hmax=Hmax,hmin=Hmin,thetamax=Thetamax,
						verbosity=Verbosity,splitpbedge=Splitpbedge,splitin2=Splitin2);		
	}
		
				
	else if(type=="UVP")
	{
		cout << " ADAPTATION TO FIELD WITH UVP STRUCTURE" << endl;	
		ifstream fileAdaptField(ffdatadir+"AdaptField.txt");
    	femp2xfemp2xfemp1 [v,u,p], [vi,ui,pii];	// real and imaginary parts
		fileAdaptField >> uC[];
		[v,u,p] = [real(vC),real(uC),real(pC)];
		[vi,ui,pii] = [imag(vC),imag(uC),imag(pC)];
		
		cout << " lecture of field with structure [U,V,P]" << endl;
		if(ui[].max<1e-6){ cout << " (Real field ; most likely a base flow) " << endl;}
		else{  cout << " (complex field ; most likely an eigenmode or response to a forcing) "<< endl; };
			
		thnew = adaptmesh(th,[v,u,p],[vi,ui,pii],[vBS,uBS,wBS,pBS],
						nbvx=Nbvx,err=error,ratio=Ratio,hmax=Hmax,hmin=Hmin,thetamax=Thetamax,
						verbosity=Verbosity,splitpbedge=Splitpbedge,splitin2=Splitin2);		
	}


	else if(type=="Comp")
	{
		cout << " ADAPTATION TO FIELD WITH UVPTRho STRUCTURE" << endl;	
		ifstream fileAdaptField(ffdatadir+"AdaptField.txt");
    		femp2xfemp2xfemp2xfemp1 [uc1,vc1,pc1,Tc1], [uc2,vc2,pc2,Tc2];	// real and imaginary parts
		fileAdaptField >> uc[];
		[uc1,vc1,pc1,Tc1] = [real(uc),real(vc),real(pc),real(Tc)];
		[uc2,vc2,pc2,Tc2] = [imag(uc),imag(vc),imag(pc),imag(Tc)];
		[uComp,vComp,pComp,TComp] = [uBc,vBc,pBc,TBc];
		cout << " lecture of field with structure [U,V,P,T,RHO]" << endl;
		if(uc2[].max<1e-6){ cout << " (Real field ; most likely a base flow) " << endl;}
		else{  cout << " (complex field ; most likely an eigenmode or response to a forcing) "<< endl; };
			
		thnew = adaptmesh(th,[uc1,vc1,pc1,Tc1],[uc2,vc2,pc2,Tc2],[uBc,vBc,pBc,TBc],
						nbvx=Nbvx,err=error,ratio=Ratio,hmax=Hmax,hmin=Hmin,thetamax=Thetamax,
						verbosity=Verbosity,splitpbedge=Splitpbedge,splitin2=Splitin2);		
	}
	
	else if(type=="UVWP")
	{
		cout << " ADAPTATION TO FIELD WITH UVWP STRUCTURE" << endl;	
		ifstream fileAdaptField(ffdatadir+"AdaptField.txt");
    	femp2xfemp2xfemp2xfemp1 [u,v,w,p], [ui,vi,wi,pii];	// real and imaginary parts
		fileAdaptField >> uCC[];
		[u,v,w,p] = [real(uCC),real(vCC),real(wCC),real(pCC)];
		[ui,vi,wi,pii] = [imag(uCC),imag(vCC),imag(wCC),imag(pCC)];
		
		cout << " lecture of field with structure [U,V,W,P]" << endl;
		if(ui[].max<1e-6){ cout << " (Real field ; most likely a base flow) " << endl;}
		else{  cout << " (complex field ; most likely an eigenmode or response to a forcing) "<< endl; };
			
		thnew = adaptmesh(th,[u,v,w,p],[ui,vi,wi,pii],[vBS,uBS,wBS,pBS],
						nbvx=Nbvx,err=error,ratio=Ratio,hmax=Hmax,hmin=Hmin,thetamax=Thetamax,
						verbosity=Verbosity,splitpbedge=Splitpbedge,splitin2=Splitin2);		
	}
	
	else if(type=="Sensitivity")
	{
		cout << " ADAPTATION TO FIELD WITH UVP STRUCTURE" << endl;	
		ifstream fileAdaptField(ffdatadir+"AdaptField.txt");
    	femp2 Sensitivity;	// real and imaginary parts
		fileAdaptField >> Sensitivity[];
				
		cout << " lecture of field with structure P2" << endl;
			
		thnew = adaptmesh(th,Sensitivity,[uBc,vBc,pBc,TBc],
						nbvx=Nbvx,err=error,ratio=Ratio,hmax=Hmax,hmin=Hmin,thetamax=Thetamax,
						verbosity=Verbosity,splitpbedge=Splitpbedge,splitin2=Splitin2);		
	}


	IFMACRO(FREEFEMPLOTS,YES)		
	plot(thold,wait=1);
	plot(thnew,wait=1);
	ENDIFMACRO
	
	savemesh(thnew,ffdatadir+"mesh.msh");
	SFWriteMesh(ffdatadir+"mesh.ff2m",thnew);


	
// INTERPOLATE BASE FLOW ON NEW MESH AND WRITE TO FILE
    fespace femp2N(thnew,P2);   
    fespace femp1N(thnew,P1);
    fespace femp0N(thnew,P0);
    fespace femp2xfemp2xfemp1N(thnew,[P2,P2,P1]);
    fespace femp2xfemp2xfemp2xfemp1N(thnew,[P2,P2,P2,P1]);
    fespace XXxxxHN(thnew,[P2,P2,P1,P1,P1]); /// 
    femp2xfemp2xfemp1N [uNx,uNy,uNp];
    XXxxxHN[uBcN,vBcN,pBcN,TBcN,rhoBcN];
  
    [uNx,uNy,uNp] = [vB,uB,pB]; // interpolation of base flow
//	plot(uBN,fill=1,wait=1);
//	plot(vBN,fill=1,wait=1);
//	plot(pBN,fill=1,wait=1);

	Re = Reans;
	real nu = 1/Re;
	cout << "Writting BaseFlow_guess" << endl;
	if(NdimBaseFlow == NdimUComp) 
	{
		[uBcN,vBcN,pBcN,TBcN,rhoBcN] = [uBc,vBc,pBc,TBc,rhoBc];
		ofstream U(ffdatadir+"BaseFlow_guess.txt");		
		U << uBcN[];
		U << endl << endl <<  Re << endl;
	}
	else{
		[uNx,uNy,uNp] = [vB,uB,pB];
		ofstream U(ffdatadir+"BaseFlow_guess.txt");		
		U << uNx[];
		U << endl << endl <<  Re << endl;

	}

// hack    
    IFMACRO(problemtype,"2D")
	SFWriteBaseFlow(ffdatadir+"BaseFlow.ff2m",uN,"BaseFlow",1);
	[uNx,uNy,uNp] = [vB,uB,pB]; // interpolation of base flow
	ofstream U(ffdatadir+"BaseFlow_guess.txt");		
        U << uNx[];
        U << endl << endl <<  Re << endl;
	ENDIFMACRO

	IFMACRO(problemtype,"AxiXR")
	femp2xfemp2xfemp1N [uNNx,uNNr,uNNp];
	[uNNx,uNNr,uNNp] = [vB,uB,pB];
	SFWriteBaseFlow(ffdatadir+"BaseFlow.ff2m",uNN,"BaseFlow",1);
	[uNx,uNy,uNp] = [vB,uB,pB];
	ofstream U(ffdatadir+"BaseFlow_guess.txt");		
        U << uNx[];
        U << endl << endl <<  Re << endl;
	ENDIFMACRO
	
	IFMACRO(problemtype,"2DComp")
	XXxxxHN[uNNc,vNNc,pNNc,TNNc,rhoNNc];
	[uNNc,vNNc,pNNc,TNNc,rhoNNc] = [uBc,vBc,pBc,TBc,rhoBc]; // interpolation of base flow
	SFWriteBaseFlow(ffdatadir+"BaseFlow.ff2m",uNNc,"BaseFlow",1);
	ENDIFMACRO

// end of hack : this is because SFWriteBaseFlow expects different component names for 2D and axi cases !


// INTERPOLATE THE DATA AND WRITE TO FILE

 
 if(type=="UVP")
   {
	femp2xfemp2xfemp1N<complex> [vCN,uCN,pCN]; 
	[vCN,uCN,pCN] = [vC,uC,pC]; // interpolation of structure
	ofstream U(ffdatadir+"AdaptField_guess.txt");		
    U << vCN[];
    U << endl << endl <<  Re << endl;
   }
   
   else if(type=="UVWP")
   {
	femp2xfemp2xfemp2xfemp1N<complex> [uCCN,vCCN,wCCN,pCCN]; 
	[uCCN,vCCN,wCCN,pCCN] = [uCC,vCC,wCC,pCC]; // interpolation of structure
	ofstream U(ffdatadir+"AdaptField_guess.txt");		
    U << uCCN[];
    U << endl << endl <<  Re << endl;
   }

   else if(type=="Comp")
   {
	XXxxxHN<complex> [ucn,vcn,pcn,Tcn,rhocn]; 
	[ucn,vcn,pcn,Tcn,rhocn] = [uc,vc,pc,Tc,rhoc]; // interpolation of structure
	ofstream U(ffdatadir+"AdaptField_guess.txt");		
	U << ucn[];
	U << endl << endl <<  Re << endl;
   }
   
   else if(type=="Sensitivity")
   {
	femp2N SensitivityN; 
	SensitivityN = Sensitivity; // interpolation of structure
	ofstream U(ffdatadir+"AdaptField_guess.txt");		
   	U << SensitivityN[];
    	U << endl << endl <<  Re << endl;
	cout << "Creating AdaptField_guess.txt" << endl;
   }


 


//	cout << "     copying  interpolated base flow to files BaseFlow_adapt.txt and BaseFlow_guess.txt " 
//	     << endl;
	     
	   
			

	

 		     	 
     	







