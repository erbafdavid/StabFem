function meshstruct = importFFmesh(fileToRead1,opt)
global ff ffdir ffdatadir sfdir verbosity

%  function importFFmesh
%  Imports mesh generated by freefem 
%  Usage : 
% 1/ mesh=importFFmesh(fileToRead1) -> imports information for points & triangles
% 2/ mesh=importFFmesh(fileToRead1,'seg') -> imports information for points, triangles & SEGMENTS (VERY INEFFICIENT, SHOULD BE IMPROVED)
%
% FileToRead1 is typically of the form "mesh.msh".
% The program will also need files "mesh.ff2m" and "SF_Init.ff2m"
%
%  This program is adapted from FreeFem_to_matlab, copyright Julien Dambrine 2010 ; 
%  modified by D. Fabre (2017)


% Check for the mesh file which should be in the ffdatadir directory
if(exist([ffdatadir,fileToRead1])==2) 
    fileToRead1 = [ffdatadir,fileToRead1];
end

%First, read auxiliary files "mesh.ff2m" and "SF_Init.ff2m"
[filepath,name,ext] = fileparts(fileToRead1);
fileToRead2 = [filepath,'/',name,'.ff2m'];
fileToRead3 = [filepath,'/SF_Init.ff2m'];

mydisp(2,['FUNCTION  importFFmesh.m : reading complementary files']);
    
meshstruct = importFFdata(fileToRead2,fileToRead3);

% change the field "datatype" to "problemtype"
meshstruct.problemtype = meshstruct.datatype;
meshstruct = rmfield(meshstruct,'datatype');

%
meshstruct.meshgeneration=0;

%Secondly, reading mesh file

rawData1 = importdata(fileToRead1);
mydisp(2,['FUNCTION  importFFmesh.m : reading file ' fileToRead1 ]);

% For some simple files (such as a CSV or JPEG files), IMPORTDATA might
% return a simple array.  If so, generate a structure so that the output
% matches that from the Import Wizard.
[unused,name] = fileparts(fileToRead1);
newData1.(genvarname(name)) = rawData1;

% Create new variables in the base workspace from those fields.
vars = fieldnames(newData1);
for i = 1:length(vars)
    assignin('base', vars{i}, newData1.(vars{i}));
end

np=rawData1(1,1);

if(nargin==2)&&(strcmp(opt,'nponly')==1) 
    meshstruct.np = np;
    return; 
end %% in case only np is required ; for instance in adaptmesh processes (NO LONGER USED)

k=0;
for i=2:np+1
    k=k+1;
points(1,k)=rawData1(i,1);
points(2,k)=rawData1(i,2);
end

nt=rawData1(1,2);
k=0;

for i=np+2:2:np+1+2*nt
k=k+1;
tri(1,k)=rawData1(i,1);
tri(2,k)=rawData1(i,2);
tri(3,k)=rawData1(i,3);
tri(4,k)=rawData1(i+1,1);
end

if(nargin==2)&&(strcmp(opt,'seg')==1)
mydisp(1,['FUNCTION  importFFmesh.m : constructing information for segments (may be long...)']);
k=0;
for i=1:nt
    k=k+1;
    lecseg(k,1)=tri(1,i);
    lecseg(k,2)=tri(2,i);
    k=k+1;
    lecseg(k,1)=tri(2,i);
    lecseg(k,2)=tri(3,i);
    k=k+1;
    lecseg(k,1)=tri(3,i);
    lecseg(k,2)=tri(1,i);
    
end

nlecseg=k;

k=0;
for i=1:nlecseg
    sw=0;
    for j=1:i-1
        if((lecseg(i,1)==lecseg(j,1) && lecseg(i,2)==lecseg(j,2)) || (lecseg(i,1)==lecseg(j,2) && lecseg(i,2)==lecseg(j,1)))
            sw=1;
        end
    end
    if(sw<1)
        k=k+1;
        seg(1,k)=lecseg(i,1);
        seg(2,k)=lecseg(i,2);
        seg(3,k)=0;
        seg(4,k)=1;
        seg(5,k)=k;
        seg(6,k)=1;
        seg(7,k)=0;
    end
end

else
    seg = 0; 
end 

meshstruct.points = points;
meshstruct.tri = tri;
meshstruct.seg = seg;
meshstruct.filename = fileToRead1;
%meshstruct.problemtype=meshstruct.datatype;
%meshstruct = rmfield(meshstruct,'datatype');

 meshstruct.np = np;

%if(np~=meshstruct.np) error('ERROR in importFFmesh.m : np in .msh and .ff2m files incompabible');
    
    
%[filepath,name,ext] = fileparts(fileToRead1);
%fileToRead2 = [filepath,'/',name,'.ff2m'];

%    mesh1.np = np;
%    meshstruct = importFFmesh(mesh1,fileToRead2);
%    meshstruct = rmfield(meshstruct,'mesh');
    % Nb this is ugly programming. to be rationalized in next version
%end


%    rawData2 = importdata([ fileToRead1 'info'] );
%    problem=rawData2.textdata{3};
%    meshstruct.problemtype=problem;
%    header = rawData2.textdata{5};
%    description=textscan(header,'%s');
%    for ii = 1:length(rawData2.data);
%        description{1}{ii};
%        meshstruct=setfield(meshstruct,description{1}{ii},rawData2.data(ii));
%    end



mydisp(2,['END FUNCTION importFFmesh.m'])
end
