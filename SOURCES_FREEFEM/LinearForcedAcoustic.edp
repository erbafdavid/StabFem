//
//  PROGRAM LinearForcedAxi_COMPLEX_m0.edp
//  computation of a linear harmonically forced problem for a single or multiple choices of omega
//
//	This solver uses the complex mapping ; 
//  The parameters of the complex mapping (ParamMap###) are defined in a file "Param_Mapping.edp" 
//
//  INPUT PARAMETERS (from keyboard or pipe) :
//   	typecalc -> 'single', 'range', or 'array'
//	 	'single' -> omega (real) (in this case a structure field is produced)
//		'range' -> omegamin, omegastep, omegamax (real)
//		'array' -> user-defined range (complex) (N, omega1, sigma1, omega2, sigma2, ....)
//
//	INPUT FILES :
//		BaseFlow.txt		-> base flow 
// 		mesh.msh 			->  mesh in Freefem format
//
//  OUTPUT FILES :
//		Impedance.ff2m -> formatted file, structure defined in macro
//		Impedance_Chi##_Re###.txt 
//
// 	ERROR MANAGEMENT : 
//
//  First version : sometime around 2014 ; Redesigned and incorporated in the project in september 2018.

cout << "$$$$ ENTERING LoopImpedance.edp " << endl << "$$" << endl; 

include "Macros_StabFem.edp";

int NNN = 10000;	
string typecalc; 
int Nomega;
complex[int] omegaarray(NNN);
	
cout << "$$ ENTERING Function LinearForcedAcoustic.edp" << endl;
cout << "$$ Selection of parameters : " << endl;

cout << "Enter the type of boundary condition (SOMMERFELD,CM,PML) : " << endl;
cin >> boundaryCondition; 

cout << "$$ Enter type  (single, range, array)  >> " ;
cin >> typecalc;
cout << typecalc << endl;
if(typecalc=="single")
	{
		cout << "$$ Enter omega  >> " ;
		cin >> omegaarray(0)  ;
		cout <<  omegaarray(0) << endl;	
		Nomega = 1;
	}
	else if(typecalc=="range")
	{
		real omegamin,omegamax,omegastep;
		cout << "$$ Enter omegamin, omegastep,  omegamax  >> " ;
		cin >> omegamin >> omegastep >> omegamax ;
		cout <<  omegamin << " , " << omegastep << " , " << omegamax << endl;
		Nomega = (omegamax-omegamin)/omegastep+1;
		for(int kk=0;kk<Nomega;kk++){omegaarray(kk) = omegamin+kk*omegastep;};
	}
	else if(typecalc=="array")
	{
		real omegar,omegai;
		cout << "$$ Enter Number of omega values N >> " ;
		cin >> Nomega;
		cout << Nomega << endl;
		cout << "$$ Enter successively omega1, sigma1, omega2, sigma2, (...) omegaN, sigmaN  >> " ;
		for(int kk=0;kk<Nomega;kk++)
		{
			cin >> omegar >> omegai; 
			omegaarray(kk) = omegar+1i*omegai;
		};
		cout << endl << "$$ (successfully read " << Nomega << " complex values " << endl;
	}
	else
	{
		cout << " Error : typecalc = " << typecalc << " is not a valid value !" << endl;
		exit(10); 
	};

	mesh th= readmesh(ffdatadir+"mesh.msh");

	real rho = 1;
	real c = 1;
	real Sin = int1d(th,2)(2*pi*x); // surface d'entr??e
	real Z0 = rho*c/Sin;// impedance carateristique du tuyau

	complex Qin ;
	//real k; // nombre d'onde k=omega*c0
			    
	fespace VH(th,P2);
	VH<complex> f,f1,ftrace;
	VH fr,fi,ft,fabs;
	complex Zin, Pin;
    

macro ForcedLinearStatisticsINIT(namefile)
{
	ofstream fileforces(namefile+".txt");
    fileforces << "%% omegar omegai Zr Zi "  << endl;			
    ofstream file(namefile+".ff2m");
    file << "### Data generated by Freefem++ ; " << endl;
    file << "Impedance of a axisymmetric acoustic flow" << endl;
    file << "datatype ForcedLinear" << endl;
	file << "real ind complex omega  complex  Z real R" << endl;
}
//EOM

macro ForcedLinearStatistics(namefile)
{
	
	complex Rate = int1d(th,2)(-2*pi*x*dy(f));
	complex pin = -rho*c*1i*k*int1d(th,2)(2*pi*x*f)/Sin;
	/*real Energy = int2d(th)(Rphys(x,y,ParamMap)/abs(Hy(y,ParamMap)*Hx(x,ParamMap))*(abs(ux)^2+abs(ur)^2));*/
	complex Imp = (pin/Rate);
	real reflection = abs((Imp-Z0)/(Imp+Z0))^2;
	cout << ">>>> JET PULSE :  k = " << k << endl;
	cout << ">>>> Debit Q = " << Rate << endl;
	cout << ">>>> DeltaP (= Pression  entree) = " << pin << endl;
	cout << ">>>> IMPEDANCE = P/Q = " << Imp << endl;
	ofstream fileforces(namefile+".txt",append);
	fileforces << ind << " " << real(k) << " " << imag(k) << " " << real(Imp) << " " << imag(Imp)  << " " <<  reflection << endl;		
	ofstream file(namefile+".ff2m",append);
	file << ind << " " << real(k) << " " << imag(k) << " " << real(Imp) << " " << imag(Imp)  << " " << reflection << endl;		
}
//EOM	


IFMACRO(!SFWriteForced)
macro SFWriteForced(namefile,f,ev)
         {
         ofstream file(namefile);
         fespace p1forff2m(th,P1); 
         p1forff2m xx,yy;
         xx=x;
         yy=y;
         complex KK = ev/1i;
         p1forff2m<complex> phi = f;
         file << "### Data generated by Freefem++ ; " << endl;
         file << "FORCED LINEAR RESPONSE for an axisymmetric acoustic problem" << endl;
         file << "datatype " << "ForcedFlow" << " datastoragemode CxP2 " << endl;
         string descriptionFF;
         descriptionFF="complex Lambda P1c phi complex Z "; 
         file << descriptionFF << endl << endl ; 
         file << real(ev) << endl << imag(ev) << endl << endl;
         for (int j=0;j<phi[].n ; j++) file << real(phi[][j]) << endl << imag(phi[][j]) << endl;        
         complex Rate = 2*pi*int1d(th,2)(dy(f)*y);
         complex Force = 2*pi*int1d(th,2)(y*1i*k*f);
         complex pin = Force/(2*pi*int1d(th,2)(y)); 
         complex ZZ = (pin/Rate);
         file << real(ZZ) << endl << imag(ZZ) << endl;  
         }
//EOM   
ENDIFMACRO

problem HelmholtzSOMMERFELD(f,f1) =
         int2d(th)( (-(dx(f)*dx(f1)+dy(f)*dy(f1))+k^2*f*f1)*2*pi*x ) // - grad (phi) * grad(phi1) dV 
       - int1d(th,1)(f1*2*pi*x)  // condition d'entr?e
	   + int1d(th,3)((1i*k-1/sqrt(x^2+y^2))*f*f1*2*pi*x) // condition de sortie de Sommerfeld (a utiliser pour les tuyaux) 
		  ;

problem HelmholtzSOMMERFELDPLANE(f,f1) =
         int2d(th)( (-(dx(f)*dx(f1)+dy(f)*dy(f1))+k^2*f*f1)*2*pi*x ) // - grad (phi) * grad(phi1) dV 
       - int1d(th,1)(f1*2*pi*x)  // condition d'entr?e
	   + int1d(th,3)(1i*k*f*f1*2*pi*x) // condition de sortie d'onde plane (a utiliser pour les pots d'?chappements)
		  ;

problem HelmholtzCM(f,f1) =
         int2d(th)( JJ*(-(Dx(f)*Dx(f1)+Dy(f)*Dy(f1))+k^2*f*f1)*2*pi*Xphys(x,y,ParamMap) ) // - grad (phi) * grad(phi1) dV 

       - int1d(th,1)(f1*2*pi*x)  // condition d'entr?e
		  ;

problem HelmholtzPML(f,f1) =
         int2d(th)( detJ*(-(S1(f)*S1(f1)+S2(f)*S2(f1))+k^2*f*f1)*2*pi*XphysPML(x,y,ParamMap) ) // - grad (phi) * grad(phi1) dV 

       - int1d(th,2)(f1*2*pi*x)  // condition d'entr?e
       	   ;

// Initialisation of output files
string namefile = ffdatadir+"LinearForcedStatistics";
ForcedLinearStatisticsINIT(namefile);	


// Loop over omega/k
for(int ind = 0; ind<Nomega; ind++)
{
	k  = omegaarray(ind);

	cout << "$$ Computation of a acoustic forced linear problem  ; " << endl;
	cout << "$$                      wavenumber: k = " << k << endl;	

	if (boundaryCondition == "SOMMERFELD")
	{
		HelmholtzSOMMERFELD;
	}
	else if (boundaryCondition == "CM")
	{
		HelmholtzCM;
	}
	else if (boundaryCondition == "PML")
	{
		HelmholtzPML;
	}
	else
	{
		cout << "No boundary condition implemented with this name. End of program." << endl;
	}
	ForcedLinearStatistics(namefile);
	
	
	
	IFMACRO(FREEFEMPLOTS,YES)
	plot(f,cmm="Structure of forced flow for k = "+k,wait=1,fill=1);
	ENDIFMACRO
	
	complex Rate = int1d(th,2)(-2*pi*x*dy(f));
	complex pin = -rho*c*1i*k*int1d(th,2)(2*pi*x*f)/Sin;
	real reflection = abs((Zin-Z0)/(Zin+Z0))^2;
	/*real Energy = int2d(th)(Rphys(x,y,ParamMap)/abs(Hy(y,ParamMap)*Hx(x,ParamMap))*(abs(ux)^2+abs(ur)^2));*/
	complex Imp = (pin/Rate);
	if(Nomega==1)
	{
    ofstream fileout("Champs_P_U_Axe.txt");
    VH yy = y;
    VH<complex> pp = 1i*k*f;
    VH<complex> u = dy(f);
    for(real zz=yy[].min; zz<yy[].max; zz=zz+ (yy[].max-yy[].min)/500)
        {
        fileout << zz << " " << real(pp(0,zz)) << " " << imag(pp(0,zz))  
                     << " " << real(u(0,zz)) << " " << imag(u(0,zz)) << endl; 
        }
    
    ofstream file(ffdatadir+"ForcedFlow.txt");
  	file << f[] ;	
   	file << endl << endl << imag(k) << "   " << -real(k)  << endl;
	SFWriteForced(ffdatadir+"ForcedFlow.ff2m",f,1i*k)
	};

};
// end Loop



cout << "$$$$ LEAVING LoopImpedance.edp " << endl << "$$" << endl; 
	
	
