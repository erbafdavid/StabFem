

// README :
// This file is adapted from "Newton_FormePont_V.edp" from "LiquidBridges++_V1.3".
// Has been updated by N. Achour & D. Fabre in July 2018



// Calcul de la forme d'equilibre d'un pont liquide axisymetrique

// La forme d'equilibre correspond a  PP0 = constante
// La methode consiste a deformer iterativement la forme 
// de la surface jusqu'a aboutir a cet equilibre.

// Remarque : la forme est parametree par la pression de reference PP0, donc la methode ne
// marche pas au voisinage d'un extremum de PP0... 
// (dans ce cas utiliser Newton_FormePont_Volume)

// La forme initiale est lue dans le fichier "MeshBridge_guess.msh". 



verbosity = 0;

// Parametres :
real Rbase = 1; // On prend le rayon du tube capillaire comme echelle de longueur (eviter de changer !)


////////////////////////////////////////////////////////////////
//
// MAILLAGE ET GEOMETRIE INITIAUX
//
////////////////////////////////////////////////////////////////

include "SF_Geom.edp";
include "Macros_StabFem.edp"

mesh th=readmesh(ffdatadir+"mesh_guess.msh");
mesh thsurface;
if(typesurfacemesh=="plain") 
{
thsurface = th; 	// Maillage 'surface'
};
if(typesurfacemesh=="empty") 
{
thsurface = emptymesh(th); 	// Maillage 'surface'
};

real PP0 = 1; // guess
real PP1;
real dpdz;
real gamma ; // tension de surface (parametre pas encore utilis√© dans cette version du programme mais a integrer proprement
string typestart; // possibilites : "pined", "axis", "plane", "freeH", "freeV"
string typeend;    // possibilites : "pined", "axis", "plane", "angle"

include "../../SOURCES_FREEFEM/Macros_Geometry_FreeSurface.edp"


/////////////////////////////////////
//
// INPUT PARAMETER
//
///////////////////////////////////////


cout << "$$ Entering FreeFem++ Program Newton_Axi_FreeSurface_Static.edp : " << endl;
cout << "$$ COMPUTATION OF A MENISCUS (static equilibrium shape of a free surface) and corresponding mesh" << endl;
cout << "$$ Input parameters : " << endl;

string typecont;
cout << "$$ Type of continuation : V (impose volume), P (impose pressure) or angle (impose angle) or S (arclength continuation) 	>> " ;
cin >>  typecont;
cout << typecont << endl;
real VolObj;
real thetaS, alphaS;

if(typecont=="V")
{
cout << "$$ Value of prescribed volume  V0    >> " ;
cin >> VolObj;
cout << VolObj << endl;
VolObj = VolObj/(2*pi);
// Warning the "volume" used in the code is actually volume/(2 pi) ; to be rationalised someday
}

else if(typecont=="P")
{
cout << "$$ Value of prescribed reference pressure P0 (at z=0)    >> " ;
cin >> PP0;
cout << PP0 << endl;
}

else if(typecont=="angle")
{
cout << "$$ Value of prescribed static angle (degrees)    >> " ;
cin >> thetaS;
cout << thetaS ;
thetaS = pi/180*thetaS;
cout << "( = " << thetaS << " radians )" << endl;
}

else if(typecont=="S")
{
cout << "$$ WARNING : type continuation 'S' not yet implemented ! " << endl;
exit(10);
}

else
{
cout << "$$ WARNING : type continuation n" << typecont << " not recognized !!! " << endl;
exit(10);
};


cout << "$$ Value of surface tension  >>" ;
cin >> gamma ;
cout << gamma << endl;

cout << "$$ Value of gravity parameter (rho g) >>  " ;
cin >> dpdz;
cout << dpdz << endl;

real GammaBar;
cout << "$$ Value of ROTATION parameter bar{Gamma}  = Gamma/(2*pi) >> " ;
cin >> GammaBar;
cout  << GammaBar << endl;
if(GammaBar!=0) {cout << " ERROR : GAMMA (rotation) NOT YET IMPLEMENTED !!!'" << endl; exit(10);};

cout << "$$ Value of parameter typestart (pined, axis, freeH or freeV) >> ";
cin >> typestart;
cout << typestart << endl;
//if(typestart=="freeH") {cout << " typestart=freeH NOT YET IMPLEMENTED !!!'" << endl; exit(10);};

cout << "$$ Value of parameter typeend (pined, axis, plane) >> "<< endl;
cin >> typeend;
if(typeend=="freeH") {cout << " typeend=freeH NOT YET IMPLEMENTED !!!'" << endl; exit(10);};

if(typecont=="angle")
{
if(typestart=="freeV"){ alphaS = 3*pi/2-thetaS;}
if(typestart=="freeH"){ alphaS = pi/-thetaS;}
if(typestart=="pined"){ cout << "error : in 'angle' mode typestart must be set to either freeV or freeH (even if it's actually pined)" << endl;}
};

/////////////////////////////////////
//
// Calcul de la geometrie initiale
//
///////////////////////////////////////


// Calcul des normales et des courbures
CalcGeomSurf;
SurfaceNumbering(IndexPointSurf,xPointSurf,yPointSurf,S0PointSurf,Nsurface);

real Zmin = yPointSurf(0);
real Zmax = yPointSurf(Nsurface);
real L = Zmax-Zmin;

////////////////////////////////////////////////////////////////
//
// ALGORIthME DE NEWTON
//
////////////////////////////////////////////////////////////////




real Res=1;
int Itmax = 30;

//Res = 0;

for(int i = 0; (i<Itmax)&(Res>1e-7);i++)
{

// Calcul de la deformation de surface 
Wh1 etaNewton ;
if(typecont=="V")
{
CalcEtaV(etaNewton,PP1,VolObj);
cout << " Modif pression : PP1 = " << PP1 << endl;
PP0 = PP0+PP1;
cout << " Nouvelle pression : PP0 : " << PP0 << endl;
}
else if(typecont=="P")
{
CalcEta(etaNewton,PP0);
}
else if(typecont=="angle")
{
CalcEtaangle(etaNewton,PP1,alphaS);
}
else
{
cout << "ERROR : typecont should only be V or P (S not implemented yet)" << endl;
exit(10);
};

IFMACRO(FREEFEMPLOTS,YES)
Vh etaext;
ExtendEta(etaext); plot(etaext,fill=1,value=1,wait=1,cmm="eta ext"); //(pour visualisation)
ENDIFMACRO

// Calcul d'un champ de deplacement du maillage 

fespace Vh11(th,[P1,P1]);
Vh11 [ur,uz];
CalcDef(ur,uz);


IFMACRO(FREEFEMPLOTS,YES)
plot([ur,uz],fill=1,value=1,cmm="champ de deformation calcule iteration "+i,wait=1);
ENDIFMACRO

// Deplacement du maillage


real minarea=checkmovemesh(th,[x+ur,y+uz]);if (minarea <0 )
	{
		cout << " WARNING : movemesh not valid. trying to underrelax by a factor 1/2" << endl;
		[ur,uz] = [ur/2,uz/2]; 
	}

th = movemesh(th,[x+ur,y+uz]);
if(typesurfacemesh=="plain") 
{
thsurface = th; 	// Maillage 'surface'
};
if(typesurfacemesh=="empty") 
{
thsurface = emptymesh(th); 	// Maillage 'surface'
};

//Shempty = emptymesh(th);
//Shempty = movemesh(Shempty,[x+urdef,y+uzdef]);
//thsurface = th;
// warning : ca ne marche qu'en mode "plain"... 

IFMACRO(FREEFEMPLOTS,YES)
plot(th,thsurface,cmm="Deformation maillage iteration "+i,wait=1);
ENDIFMACRO

// Recalcul des normales et courbures
CalcGeomSurf;
ExtendC;
K0ext = K0ext-(PP0-dpdz*y);
IFMACRO(FREEFEMPLOTS,YES)
plot(K0ext,fill=1,value=1,cmm="Erreur courbure iteration "+i,wait=1);
ENDIFMACRO

real NewVolume = int2d(th)(x);
//cout << "NewVolume = " << NewVolume << endl; 

//Res = int1d(Shempty,2)( (K0a+K0b-(K0-dpdz*y))^2 );
Res = int1d(thsurface,2)(abs(x)*(gamma*(K0a+K0b)-(PP0-dpdz*y))^2);
cout << " iteration " << i << " : Res = " << Res << " ; Volume = " << NewVolume << " ; PP0 = " << PP0 << " ; angle = " << alphaPointSurf(0) <<  endl; 


//cout << " Max(eta) :" << etaNewton[].max << endl;

}
//  ----------------------------------------------------------------------------------------------------
// Fin du Newton 
//  ----------------------------------------------------------------------------------------------------


cout << endl << " ------- NEWTON TERMINE -------" << endl << endl;
// Ecriture du maillage dans un fichier

if (Res < 1e-4)
{ cout << "solution convergee : on copie le maillage dans mesh.msh" << endl;
 savemesh(th,ffdatadir+"mesh.msh");
 savemesh(th,ffdatadir+"mesh_guess.msh");
 
 SFWriteMesh(ffdatadir+"mesh.ff2m",th)
  
 real NewVolume = int2d(th)(x);
 
 cout << "$$ Statistique sur geometrie" << endl;
 cout << "$$ P0 = " << PP0 << endl;
 cout << "$$ Volume = " << 2*pi*NewVolume << "       ( Volume / 2pi = " << NewVolume << " ) " << endl;  
 cout << "$$ Angle at starting point = " << alphaPointSurf(0)*180/pi << "      ( = " << alphaPointSurf(0) << " radians )" << endl; 
}
else
{
cout << "ATTENTION : pas de convergence du Newton !" << endl;
exit(10);
};





//exec("cp "+ffdatadir+"mesh.msh "+ffdatadir+"mesh_guess.msh");
//exec("cp "+ffdatadir+"mesh.ff2m "+ffdatadir+"mesh_guess.ff2m");

	
	
//// EXPORTATION DU CHAMP DE BASE AUX FORMAT FF2M
	
	
//		fespace femp2(th,P2);
//		femp2 phi = 0;
//		fespace femp1(th,P1);
//		femp1 phiP1 = 0;
				
//		ofstream file(ffdatadir+"BaseFlow.txt");
//	    file << phi[] << endl;
//	    file <<  endl << 0 << endl;


//SFWriteBaseFlow(ffdatadir+"BaseFlow.ff2m",phiP1);



cout << endl << "The end..." << endl << endl;
